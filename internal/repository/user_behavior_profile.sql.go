// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_behavior_profile.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserProfileByUserID = `-- name: GetUserProfileByUserID :one
SELECT
    user_id,
    average_transaction_amount,
    std_dev_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes::text[] AS registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    total_transactions,
    allowed_transactions,
    updated_at
FROM user_profile_behavior
WHERE user_id = $1
`

type GetUserProfileByUserIDRow struct {
	UserID                            int32            `json:"user_id"`
	AverageTransactionAmount          pgtype.Float8    `json:"average_transaction_amount"`
	StdDevTransactionAmount           pgtype.Int4      `json:"std_dev_transaction_amount"`
	MaxTransactionAmountSeen          pgtype.Float8    `json:"max_transaction_amount_seen"`
	AverageNumberOfTransactionsPerDay pgtype.Int4      `json:"average_number_of_transactions_per_day"`
	RegisteredPaymentModes            []string         `json:"registered_payment_modes"`
	UsualTransactionStartHour         pgtype.Timestamp `json:"usual_transaction_start_hour"`
	UsualTransactionEndHour           pgtype.Timestamp `json:"usual_transaction_end_hour"`
	TotalTransactions                 int32            `json:"total_transactions"`
	AllowedTransactions               int32            `json:"allowed_transactions"`
	UpdatedAt                         pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserProfileByUserID(ctx context.Context, userID int32) (GetUserProfileByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getUserProfileByUserID, userID)
	var i GetUserProfileByUserIDRow
	err := row.Scan(
		&i.UserID,
		&i.AverageTransactionAmount,
		&i.StdDevTransactionAmount,
		&i.MaxTransactionAmountSeen,
		&i.AverageNumberOfTransactionsPerDay,
		&i.RegisteredPaymentModes,
		&i.UsualTransactionStartHour,
		&i.UsualTransactionEndHour,
		&i.TotalTransactions,
		&i.AllowedTransactions,
		&i.UpdatedAt,
	)
	return i, err
}

const rebuildAllUserProfiles = `-- name: RebuildAllUserProfiles :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    std_dev_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    updated_at
)
SELECT
    t.user_id,

    COALESCE(
        AVG(t.amount) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS average_transaction_amount,

    COALESCE(
        STDDEV(t.amount) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS std_dev_transaction_amount,

    COALESCE(MAX(t.amount), 0)::INTEGER AS max_transaction_amount_seen,

    LEAST(
        COUNT(*) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        50
    )::INTEGER AS average_number_of_transactions_per_day,

    COALESCE(
        (ARRAY_AGG(DISTINCT t.mode) 
            FILTER (WHERE t.decision IN ('ALLOW', 'FLAG'))),
        ARRAY[]::mode[]
    ) AS registered_payment_modes,

    MIN(t.created_at)
        FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS usual_transaction_start_hour,

    MAX(t.created_at)
        FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS usual_transaction_end_hour,

    NOW() AS updated_at

FROM transactions t
WHERE t.created_at < CURRENT_DATE
GROUP BY t.user_id

ON CONFLICT (user_id) DO UPDATE SET
    average_transaction_amount = EXCLUDED.average_transaction_amount,
    std_dev_transaction_amount = EXCLUDED.std_dev_transaction_amount,
    max_transaction_amount_seen = EXCLUDED.max_transaction_amount_seen,
    average_number_of_transactions_per_day = EXCLUDED.average_number_of_transactions_per_day,
    registered_payment_modes = EXCLUDED.registered_payment_modes,
    usual_transaction_start_hour = EXCLUDED.usual_transaction_start_hour,
    usual_transaction_end_hour = EXCLUDED.usual_transaction_end_hour,
    updated_at = EXCLUDED.updated_at
`

func (q *Queries) RebuildAllUserProfiles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, rebuildAllUserProfiles)
	return err
}

const recalculateUserProfile = `-- name: RecalculateUserProfile :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    std_dev_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    total_transactions,
    allowed_transactions,
    updated_at
)
SELECT
    u.id AS user_id,

    COALESCE(
        AVG(t.amount) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS average_transaction_amount,

    COALESCE(
        STDDEV(t.amount) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS std_dev_transaction_amount,

    COALESCE(MAX(t.amount), 0)::INTEGER AS max_transaction_amount_seen,

    LEAST(
        COUNT(*) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) / GREATEST(DATE_PART('day', NOW() - MIN(t.created_at)), 1),
        50
    )::INTEGER AS average_number_of_transactions_per_day,

    COALESCE(
        ARRAY_AGG(DISTINCT t.mode) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        ARRAY[]::mode[]
    ) AS registered_payment_modes,

    MIN(t.created_at)
        FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS usual_transaction_start_hour,

    MAX(t.created_at)
        FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS usual_transaction_end_hour,

    COUNT(t.id) AS total_transactions,

    COUNT(t.id) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS allowed_transactions,

    NOW() AS updated_at
FROM users u
LEFT JOIN transactions t
    ON t.user_id = u.id
WHERE u.id = $1
GROUP BY u.id

ON CONFLICT (user_id) DO UPDATE SET
    average_transaction_amount = EXCLUDED.average_transaction_amount,
    std_dev_transaction_amount = EXCLUDED.std_dev_transaction_amount,
    max_transaction_amount_seen = EXCLUDED.max_transaction_amount_seen,
    average_number_of_transactions_per_day = EXCLUDED.average_number_of_transactions_per_day,
    registered_payment_modes = EXCLUDED.registered_payment_modes,
    usual_transaction_start_hour = EXCLUDED.usual_transaction_start_hour,
    usual_transaction_end_hour = EXCLUDED.usual_transaction_end_hour,
    total_transactions = EXCLUDED.total_transactions,
    allowed_transactions = EXCLUDED.allowed_transactions,
    updated_at = EXCLUDED.updated_at
`

func (q *Queries) RecalculateUserProfile(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, recalculateUserProfile, id)
	return err
}

const upsertUserProfileByUserID = `-- name: UpsertUserProfileByUserID :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    std_dev_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    total_transactions,
    allowed_transactions,
    updated_at
)
SELECT
    u.id AS user_id,

    COALESCE(
        AVG(t.amount) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS average_transaction_amount,

    COALESCE(
        STDDEV(t.amount) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS std_dev_transaction_amount,

    COALESCE(MAX(t.amount), 0)::INTEGER AS max_transaction_amount_seen,

    LEAST(
        COUNT(*) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        50
    )::INTEGER AS average_number_of_transactions_per_day,

    COALESCE(
        ARRAY_AGG(DISTINCT t.mode) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')),
        ARRAY[]::mode[]
    ) AS registered_payment_modes,

    MIN(t.created_at)
        FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS usual_transaction_start_hour,

    MAX(t.created_at)
        FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS usual_transaction_end_hour,

    COUNT(t.id) AS total_transactions,

    COUNT(t.id) FILTER (WHERE t.decision IN ('ALLOW', 'FLAG')) AS allowed_transactions,

    NOW() AS updated_at
FROM users u
LEFT JOIN transactions t
    ON t.user_id = u.id
    AND t.created_at < CURRENT_DATE
WHERE u.id = $1
GROUP BY u.id

ON CONFLICT (user_id) DO UPDATE SET
    average_transaction_amount = EXCLUDED.average_transaction_amount,
    std_dev_transaction_amount = EXCLUDED.std_dev_transaction_amount,
    max_transaction_amount_seen = EXCLUDED.max_transaction_amount_seen,
    average_number_of_transactions_per_day = EXCLUDED.average_number_of_transactions_per_day,
    registered_payment_modes = EXCLUDED.registered_payment_modes,
    usual_transaction_start_hour = EXCLUDED.usual_transaction_start_hour,
    usual_transaction_end_hour = EXCLUDED.usual_transaction_end_hour,
    total_transactions = EXCLUDED.total_transactions,
    allowed_transactions = EXCLUDED.allowed_transactions,
    updated_at = EXCLUDED.updated_at
`

func (q *Queries) UpsertUserProfileByUserID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, upsertUserProfileByUserID, id)
	return err
}

const upsertUserProfileFromProfile = `-- name: UpsertUserProfileFromProfile :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    std_dev_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    total_transactions,
    allowed_transactions,
    updated_at
)
VALUES (
    $1,  -- user_id
    $2,  -- average_transaction_amount
    $3,  -- std_dev_transaction_amount
    $4,  -- max_transaction_amount_seen
    $5,  -- average_number_of_transactions_per_day
    $6,  -- registered_payment_modes
    $7,  -- usual_transaction_start_hour
    $8,  -- usual_transaction_end_hour
    $9,  -- total_transactions
    $10, -- allowed_transactions
    NOW()
)
ON CONFLICT (user_id) DO UPDATE SET
    average_transaction_amount = EXCLUDED.average_transaction_amount,
    std_dev_transaction_amount = EXCLUDED.std_dev_transaction_amount,
    max_transaction_amount_seen = EXCLUDED.max_transaction_amount_seen,
    average_number_of_transactions_per_day = EXCLUDED.average_number_of_transactions_per_day,
    registered_payment_modes = EXCLUDED.registered_payment_modes,
    usual_transaction_start_hour = EXCLUDED.usual_transaction_start_hour,
    usual_transaction_end_hour = EXCLUDED.usual_transaction_end_hour,
    total_transactions = EXCLUDED.total_transactions,
    allowed_transactions = EXCLUDED.allowed_transactions,
    updated_at = NOW()
`

type UpsertUserProfileFromProfileParams struct {
	UserID                            int32            `json:"user_id"`
	AverageTransactionAmount          pgtype.Float8    `json:"average_transaction_amount"`
	StdDevTransactionAmount           pgtype.Int4      `json:"std_dev_transaction_amount"`
	MaxTransactionAmountSeen          pgtype.Float8    `json:"max_transaction_amount_seen"`
	AverageNumberOfTransactionsPerDay pgtype.Int4      `json:"average_number_of_transactions_per_day"`
	RegisteredPaymentModes            []Mode           `json:"registered_payment_modes"`
	UsualTransactionStartHour         pgtype.Timestamp `json:"usual_transaction_start_hour"`
	UsualTransactionEndHour           pgtype.Timestamp `json:"usual_transaction_end_hour"`
	TotalTransactions                 int32            `json:"total_transactions"`
	AllowedTransactions               int32            `json:"allowed_transactions"`
}

func (q *Queries) UpsertUserProfileFromProfile(ctx context.Context, arg UpsertUserProfileFromProfileParams) error {
	_, err := q.db.Exec(ctx, upsertUserProfileFromProfile,
		arg.UserID,
		arg.AverageTransactionAmount,
		arg.StdDevTransactionAmount,
		arg.MaxTransactionAmountSeen,
		arg.AverageNumberOfTransactionsPerDay,
		arg.RegisteredPaymentModes,
		arg.UsualTransactionStartHour,
		arg.UsualTransactionEndHour,
		arg.TotalTransactions,
		arg.AllowedTransactions,
	)
	return err
}
