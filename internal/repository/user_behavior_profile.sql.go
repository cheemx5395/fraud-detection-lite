// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_behavior_profile.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmptyUserProfile = `-- name: CreateEmptyUserProfile :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    updated_at
)
VALUES (
    $1,
    0,
    0,
    0,
    '{}',
    NULL,
    NULL,
    NOW()
)
ON CONFLICT (user_id) DO NOTHING
`

func (q *Queries) CreateEmptyUserProfile(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, createEmptyUserProfile, userID)
	return err
}

const getUserProfileByUserID = `-- name: GetUserProfileByUserID :one
SELECT
    user_id,
    average_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes::text[] AS registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    total_transactions,
    allowed_transactions,
    updated_at
FROM user_profile_behavior
WHERE user_id = $1
`

type GetUserProfileByUserIDRow struct {
	UserID                            int32            `json:"user_id"`
	AverageTransactionAmount          pgtype.Int4      `json:"average_transaction_amount"`
	MaxTransactionAmountSeen          pgtype.Int4      `json:"max_transaction_amount_seen"`
	AverageNumberOfTransactionsPerDay pgtype.Int4      `json:"average_number_of_transactions_per_day"`
	RegisteredPaymentModes            []string         `json:"registered_payment_modes"`
	UsualTransactionStartHour         pgtype.Timestamp `json:"usual_transaction_start_hour"`
	UsualTransactionEndHour           pgtype.Timestamp `json:"usual_transaction_end_hour"`
	TotalTransactions                 int32            `json:"total_transactions"`
	AllowedTransactions               int32            `json:"allowed_transactions"`
	UpdatedAt                         pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserProfileByUserID(ctx context.Context, userID int32) (GetUserProfileByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getUserProfileByUserID, userID)
	var i GetUserProfileByUserIDRow
	err := row.Scan(
		&i.UserID,
		&i.AverageTransactionAmount,
		&i.MaxTransactionAmountSeen,
		&i.AverageNumberOfTransactionsPerDay,
		&i.RegisteredPaymentModes,
		&i.UsualTransactionStartHour,
		&i.UsualTransactionEndHour,
		&i.TotalTransactions,
		&i.AllowedTransactions,
		&i.UpdatedAt,
	)
	return i, err
}

const rebuildAllUserProfiles = `-- name: RebuildAllUserProfiles :exec
BEGIN
`

func (q *Queries) RebuildAllUserProfiles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, rebuildAllUserProfiles)
	return err
}

const rebuildProfilesForSeededUsers = `-- name: RebuildProfilesForSeededUsers :exec
SELECT RebuildAllUserProfiles()
`

func (q *Queries) RebuildProfilesForSeededUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, rebuildProfilesForSeededUsers)
	return err
}

const rebuildUserProfileByID = `-- name: RebuildUserProfileByID :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    total_transactions,
    allowed_transactions,
    updated_at
)
SELECT 
    $1::INTEGER AS user_id,

    COALESCE(
        AVG(amount) FILTER (WHERE decision IN ('ALLOW', 'FLAG')),
        0
    )::INTEGER AS average_transaction_amount,

    COALESCE(MAX(amount), 0)::INTEGER AS max_transaction_amount_seen,

    LEAST(
        COUNT(*) FILTER (WHERE decision IN ('ALLOW', 'FLAG')),
        50
    )::INTEGER AS average_number_of_transactions_per_day,

    ARRAY_AGG(DISTINCT mode)
        FILTER (WHERE decision IN ('ALLOW', 'FLAG')) AS registered_payment_modes,

    MIN(created_at)
        FILTER (WHERE decision IN ('ALLOW', 'FLAG')) AS usual_transaction_start_hour,

    MAX(created_at)
        FILTER (WHERE decision IN ('ALLOW', 'FLAG')) AS usual_transaction_end_hour,

    COUNT(*) AS total_transactions,

    COUNT(*) FILTER (WHERE decision IN ('ALLOW', 'FLAG')) AS allowed_transactions,

    NOW() AS updated_at

FROM transactions
WHERE user_id = $1
  AND created_at < CURRENT_DATE

ON CONFLICT (user_id) DO UPDATE SET 
    average_transaction_amount = EXCLUDED.average_transaction_amount,
    max_transaction_amount_seen = EXCLUDED.max_transaction_amount_seen,
    average_number_of_transactions_per_day = EXCLUDED.average_number_of_transactions_per_day,
    registered_payment_modes = EXCLUDED.registered_payment_modes,
    usual_transaction_start_hour = EXCLUDED.usual_transaction_start_hour,
    usual_transaction_end_hour = EXCLUDED.usual_transaction_end_hour,
    total_transactions = EXCLUDED.total_transactions,
    allowed_transactions = EXCLUDED.allowed_transactions,
    updated_at = EXCLUDED.updated_at
`

func (q *Queries) RebuildUserProfileByID(ctx context.Context, dollar_1 int32) error {
	_, err := q.db.Exec(ctx, rebuildUserProfileByID, dollar_1)
	return err
}

const seedUserBehaviorProfiles = `-- name: SeedUserBehaviorProfiles :exec
INSERT INTO user_profile_behavior (
    user_id,
    average_transaction_amount,
    max_transaction_amount_seen,
    average_number_of_transactions_per_day,
    registered_payment_modes,
    usual_transaction_start_hour,
    usual_transaction_end_hour,
    updated_at
)
SELECT
    u.id,
    0,
    0,
    0,
    '{}',
    NULL,
    NULL,
    NOW()
FROM users u
ON CONFLICT (user_id) DO NOTHING
`

func (q *Queries) SeedUserBehaviorProfiles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, seedUserBehaviorProfiles)
	return err
}

const userProfileExists = `-- name: UserProfileExists :one
SELECT EXISTS (
    SELECT 1
    FROM user_profile_behavior
    WHERE user_id = $1
)
`

func (q *Queries) UserProfileExists(ctx context.Context, userID int32) (bool, error) {
	row := q.db.QueryRow(ctx, userProfileExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
